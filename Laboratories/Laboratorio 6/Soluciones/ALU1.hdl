// This file contains the solution to the Lab07.
// Made by Juan Esteban Sánchez García

/* * Chip that implements a 2-bit Arithmetic Logic Unit (ALU).
 * It performs four basic operations on two 2-bit inputs A(A1, A0) and B(B1, B0), 
 * selected by the 2-bit control signals f(f1, f0).
 * * CONTROL SIGNALS (f1, f0):
 * Sum (00): C1, C0 = A + B (C is the final carry-out)
 * Not (01): C1, C0 = Not(A)
 * Or (10): C1, C0 = A Or B
 * And (11): C1, C0 = A And B 
 */

CHIP ALU1 
{
    IN f1, f0, A1, A0, B1, B0;
    OUT C, C1, C0;

    PARTS:
    // ========================================================================
    // CONTROL AND INPUT PRE-PROCESSING
    // ========================================================================
    Not(in=f1, out=f1N); // f1' (Not f1)
    Not(in=f0, out=f0N); // f0' (Not f0)
    Not(in=A1, out=A1N); // A1' (Not A1)
    Not(in=A0, out=A0N); // A0' (Not A0)
    Not(in=B1, out=B1N); // B1' (Not B1)
    Not(in=B0, out=B0N); // B0' (Not B0)
    
    // Auxiliary terms for operations (AND, OR, XOR)

    And(a=A0, b=B0, out=abAND0); // A0 AND B0
    And(a=A1, b=B1, out=abAND1); // A1 AND B1
    And(a=A0, b=A1, out=a01AND); // A0 AND A1
    And(a=B0, b=B1, out=b01AND); // B0 AND B1
    Or(a=A1, b=B1, out=abOR1); // A1 OR B1
    Or(a=A0N, b=B0N, out=abORN0); // A0' OR B0'
    Xor(a=A1, b=B1, out=abXOR1); // A1 XOR B1

    // Auxiliary terms for control signals (f1, f0)

    And(a=A1N, b=f0N, out=af10ANDN); // A1' AND f0'
    And(a=f0N, b=f1N, out=f01ANDN); // f0' AND f1' (Select Sum: 00)
    And(a=f1, b=f0N, out=f10ANDN); // f1 AND f0' (Select Or: 10)
    And(a=B0, b=f0, out=bfAND0); // B0 AND f0
    And(a=B0, b=f1N, out=bf01AND); // B0 AND f1'
    And(a=B0N, b=f1N, out=bf01ANDN); // B0' AND f1'

    // ========================================================================
    // OUTPUT C (Carry-out of the 2-bit Sum operation)
    // C = (A1 B1 + A0 B0 (A1 + B1) ) * f0' f1' 
    // This is the carry-out only when (f1,f0) = 00 (Sum)
    // ========================================================================

    And(a=abAND0, b=abOR1, out=x1); // A0 B0 (A1 + B1)
    Or(a=abAND1, b=x1, out=x2); // A1 B1 + A0 B0 (A1 + B1)
    And(a=x2, b=f01ANDN, out=C); // C * (f0' f1')

    // ========================================================================
    // OUTPUT C1 (Most Significant Bit of the Result)
    // C1 is implemented using a large multiplexer logic based on f1 and f0
    // C1 = 
    // (A1 B1 f0) + 
    // (A1' f0' (f1 + A0 B0 B1')) + 
    // ((A0 A1 B0 B1 + f0 (A1+B1) + (A0'+B0')(A1 XOR B1) ) f1')
    // ========================================================================
    
    
    // Part 1: A1 B1 f0
    And(a=abAND1, b=f0, out=y1);

    // Part 2: A1' f0' (f1 + A0 B0 B1')

    And(a=abAND0, b=B1N, out=y2); // A0 B0 B1'
    Or(a=f1, b=y2, out=y3); // f1 + A0 B0 B1'
    And(a=af10ANDN, b=y3, out=y4); // A1' f0' * (f1 + A0 B0 B1')

    // Part 3: (A0 A1 B0 B1 + f0 (A1+B1) + (A0'+B0')(A1 XOR B1) ) f1'

    And(a=a01AND, b=b01AND, out=y5); // A0 A1 B0 B1
    And(a=f0, b=abOR1, out=y6); // f0 (A1+B1)
    And(a=abORN0, b=abXOR1, out=y7); // (A0'+B0')(A1 XOR B1)
    Or(a=y5, b=y6, out=y8); 
    Or(a=y8, b=y7, out=y9); // (y5 + y6 + y7)
    And(a=y9, b=f1N, out=y10); // (y9) * f1'

    // Final C1: y1 + y4 + y10
    
    Or(a=y1, b=y4, out=y11);
    Or(a=y11, b=y10, out=C1);

    // ========================================================================
    // OUTPUT C0 (Least Significant Bit of the Result)
    // C0 is implemented using a large multiplexer logic based on f1 and f0
    // C0 = A0' (f1 f0'+ B0 f1') + A0 (B0 f0 + B0' f1')
    // ========================================================================
    
    // Part 1: A0' (f1 f0'+ B0 f1')

    Or(a=f10ANDN, b=bf01AND, out=z1); // (f1 f0'+ B0 f1')
    And(a=A0N, b=z1, out=z2); // A0' * (z1)
    
    // Part 2: A0 (B0 f0 + B0' f1')

    Or(a=bfAND0, b=bf01ANDN, out=z3); // (B0 f0 + B0' f1')
    And(a=A0, b=z3, out=z4); // A0 * (z3)

    // Final C0: z2 + z4

    Or(a=z2, b=z4, out=C0);
}