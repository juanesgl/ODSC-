/**
 * AU — Arithmetic Unit (Custom 48-bit Multi-Path Operator)
 * --------------------------------------------------------
 * The AU performs several arithmetic and data-routing operations across
 * three independent 48-bit channels: CI, A, and SL. Each channel is
 * represented as four 12-bit segments (0..3), forming a wide 48-bit word.
 *
 * The operation to execute is selected by `inst[3]`, which is decoded
 * into eight mutually exclusive control signals (000 to 111).
 *
 * Supported Operations (by instruction code):
 *
 *   000 — CIout ← SLin
 *       Directly forwards SLin into CIout.
 *
 *   001 — CIout ← CIin + SLin
 *       48-bit addition of CIin and SLin.
 *
 *   010 — Aout ← −SLin
 *       Two's-complement negation of SLin.
 *
 *   011 — SLout ← Ain
 *       Passes Ain directly to SLout.
 *
 *   100 — Aout ← Ain − SLin
 *       48-bit subtraction.
 *
 *   101 — Aout ← Ain − SLin
 *       Same as 100, reserved for micro-architectural variations.
 *
 *   110 — If Ain < 0 then CIout ← CIin + 1
 *       Detects negativity via MSB (Ain3[11]); conditionally increments CI.
 *
 *   111 — (Unused)
 *       Included for completeness of the DMux8Way decode tree.
 */

CHIP AU {
    IN CIin0[12], CIin1[12], CIin2[12], CIin3[12],
       Ain0[12], Ain1[12], Ain2[12], Ain3[12],
       SLin0[12], SLin1[12], SLin2[12], SLin3[12],
       inst[3];

    OUT CIout0[12], CIout1[12], CIout2[12], CIout3[12],
        Aout0[12], Aout1[12], Aout2[12], Aout3[12],
        SLout0[12], SLout1[12], SLout2[12], SLout3[12];

    PARTS:

    // Replicated constant FALSE (12 bits)

    Replicate12(in=false, out=false12);

    // Decode the 3-bit instruction into 8 exclusive operation flags

    DMux8Way(in=true, sel=inst, a=op000, b=op001, c=op010, d=op011, 
             e=op100, f=op101, g=op110, h=op111);

    // Replicate each control signal to 12-bit masks

    Replicate12(in=op000, out=op000rep);
    Replicate12(in=op001, out=op001rep);
    Replicate12(in=op010, out=op010rep);
    Replicate12(in=op011, out=op011rep);
    Replicate12(in=op100, out=op100rep);
    Replicate12(in=op101, out=op101rep);
    Replicate12(in=op110, out=op110rep);

    // ========================================================
    // ================ Constructing CIout =====================
    // ========================================================

    // 000: CIout ← SLin

    And12(a=SLin0, b=op000rep, out=ci0000);
    And12(a=SLin1, b=op000rep, out=ci0001);
    And12(a=SLin2, b=op000rep, out=ci0002);
    And12(a=SLin3, b=op000rep, out=ci0003);

    // 001: CIout ← CIin + SLin  (48-bit addition)

    Add48(a3=CIin3, a2=CIin2, a1=CIin1, a0=CIin0,
          b3=SLin3, b2=SLin2, b1=SLin1, b0=SLin0,
          out3=sum0013, out2=sum0012, out1=sum0011, out0=sum0010);

    // Masked sum for op001

    And12(a=sum0010, b=op001rep, out=ci0010);
    And12(a=sum0011, b=op001rep, out=ci0011);
    And12(a=sum0012, b=op001rep, out=ci0012);
    And12(a=sum0013, b=op001rep, out=ci0013);

    // 110: If Ain < 0 then CIout ← CIin + 1
    // MSB of the 48-bit Ain word is Ain3[11]

    And(a=Ain3[11], b=op110, out=ainNegative);
    Replicate12(in=ainNegative, out=ainNegRep);

    // CIin + 1

    Inc48(in3=CIin3, in2=CIin2, in1=CIin1, in0=CIin0,
          out3=inc3, out2=inc2, out1=inc1, out0=inc0);

    // Masked output for op110

    And12(a=inc0, b=ainNegRep, out=ci1100);
    And12(a=inc1, b=ainNegRep, out=ci1101);
    And12(a=inc2, b=ainNegRep, out=ci1102);
    And12(a=inc3, b=ainNegRep, out=ci1103);

    // Combine all CIout candidates (only one active)

    Or12(a=ci0000, b=ci0010, out=tmpci0);
    Or12(a=tmpci0, b=ci1100, out=CIout0);

    Or12(a=ci0001, b=ci0011, out=tmpci1);
    Or12(a=tmpci1, b=ci1101, out=CIout1);

    Or12(a=ci0002, b=ci0012, out=tmpci2);
    Or12(a=tmpci2, b=ci1102, out=CIout2);

    Or12(a=ci0003, b=ci0013, out=tmpci3);
    Or12(a=tmpci3, b=ci1103, out=CIout3);

    // ========================================================
    // ================= Constructing Aout =====================
    // ========================================================

    // 010: Aout ← −SLin  (two's complement)

    Negate48(in3=SLin3, in2=SLin2, in1=SLin1, in0=SLin0, 
             out3=neg3, out2=neg2, out1=neg1, out0=neg0);

    And12(a=neg0, b=op010rep, out=a0100);
    And12(a=neg1, b=op010rep, out=a0101);
    And12(a=neg2, b=op010rep, out=a0102);
    And12(a=neg3, b=op010rep, out=a0103);

    // 100: Aout ← Ain − SLin
    // 101: Same as above (reserved alias)

    Sub48(a3=Ain3, a2=Ain2, a1=Ain1, a0=Ain0,
          b3=SLin3, b2=SLin2, b1=SLin1, b0=SLin0,
          out3=sub3, out2=sub2, out1=sub1, out0=sub0);

    // Masked subtraction outputs

    And12(a=sub0, b=op100rep, out=a1000);
    And12(a=sub1, b=op100rep, out=a1001);
    And12(a=sub2, b=op100rep, out=a1002);
    And12(a=sub3, b=op100rep, out=a1003);

    And12(a=sub0, b=op101rep, out=a1010);
    And12(a=sub1, b=op101rep, out=a1011);
    And12(a=sub2, b=op101rep, out=a1012);
    And12(a=sub3, b=op101rep, out=a1013);

    // Combine Aout candidates
    Or12(a=a0100, b=a1000, out=tmpa0);
    Or12(a=tmpa0, b=a1010, out=Aout0);

    Or12(a=a0101, b=a1001, out=tmpa1);
    Or12(a=tmpa1, b=a1011, out=Aout1);

    Or12(a=a0102, b=a1002, out=tmpa2);
    Or12(a=tmpa2, b=a1012, out=Aout2);

    Or12(a=a0103, b=a1003, out=tmpa3);
    Or12(a=tmpa3, b=a1013, out=Aout3);

    // ========================================================
    // ================= Constructing SLout ====================
    // ========================================================

    // 011: SLout ← Ain

    And12(a=Ain0, b=op011rep, out=sl0110);
    And12(a=Ain1, b=op011rep, out=sl0111);
    And12(a=Ain2, b=op011rep, out=sl0112);
    And12(a=Ain3, b=op011rep, out=sl0113);

    // SLout is simply Ain masked (no other SLout-producing ops)

    Or12(a=sl0110, b=false12, out=SLout0);
    Or12(a=sl0111, b=false12, out=SLout1);
    Or12(a=sl0112, b=false12, out=SLout2);
    Or12(a=sl0113, b=false12, out=SLout3);
}